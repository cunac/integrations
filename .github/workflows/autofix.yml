name: Auto-Fix CI Failures

on:
  workflow_call:
    inputs:
      failed_job:
        description: 'Name of the job that failed'
        required: true
        type: string
      run_url:
        description: 'URL of the failed workflow run'
        required: true
        type: string
      branch:
        description: 'Branch where the failure occurred'
        required: true
        type: string
      sha:
        description: 'Commit SHA where the failure occurred'
        required: true
        type: string
  workflow_dispatch:
    inputs:
      failed_job:
        description: 'Name of the job that failed'
        required: true
        type: string
      branch:
        description: 'Branch to fix'
        required: true
        default: 'main'

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

    steps:
    - name: Check OpenAI API Key
      id: check_key
      run: |
        if [ -z "$OPENAI_API_KEY" ]; then
          echo "⚠️ OPENAI_API_KEY secret is not set. Skipping auto-fix."
          echo "To enable auto-fix, add OPENAI_API_KEY to repository secrets."
          echo "has_key=false" >> $GITHUB_OUTPUT
          exit 0
        else
          echo "✅ OPENAI_API_KEY is configured"
          echo "has_key=true" >> $GITHUB_OUTPUT
        fi

    - name: Checkout code
      if: steps.check_key.outputs.has_key == 'true'
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.sha || github.sha }}
        fetch-depth: 0

    - name: Set up JDK 17
      if: steps.check_key.outputs.has_key == 'true'
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: 'gradle'

    - name: Make gradlew executable
      if: steps.check_key.outputs.has_key == 'true'
      run: chmod +x gradlew

    - name: Collect failure information
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Collecting test failure information..."
        ./gradlew test --no-daemon --stacktrace 2>&1 | tee test-output.log || true

        # Extract relevant error information
        echo "Extracting failure details..."
        grep -A 10 "FAILED\|FAILURE\|Error" test-output.log > failures.txt || echo "No specific failures found in output"

    - name: Collect coverage information
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Generating coverage report..."
        ./gradlew jacocoTestReport jacocoTestCoverageVerification --no-daemon --stacktrace 2>&1 | tee coverage-output.log || true

        # Extract coverage violations
        echo "Extracting coverage violations..."
        grep -A 5 "Rule violated\|Coverage\|COVEREDRATIO\|minimum" coverage-output.log > coverage-violations.txt || echo "No coverage violations found"

        # Parse JaCoCo CSV for detailed coverage info
        if [ -f "build/reports/jacoco/test/jacocoTestReport.csv" ]; then
          echo "Coverage report found, extracting details..."
          cat build/reports/jacoco/test/jacocoTestReport.csv > coverage-report.csv

          # Calculate coverage percentages
          echo "=== Coverage Summary ===" > coverage-summary.txt
          awk -F',' 'NR>1 {
            class=$3
            inst_miss=$4
            inst_cov=$5
            branch_miss=$6
            branch_cov=$7
            line_miss=$8
            line_cov=$9

            if (inst_miss + inst_cov > 0) {
              inst_pct = (inst_cov / (inst_miss + inst_cov)) * 100
            } else {
              inst_pct = 0
            }

            if (line_miss + line_cov > 0) {
              line_pct = (line_cov / (line_miss + line_cov)) * 100
            } else {
              line_pct = 0
            }

            printf "%s: %.2f%% instruction coverage, %.2f%% line coverage (Lines: %d covered, %d missed)\n",
              class, inst_pct, line_pct, line_cov, line_miss
          }' build/reports/jacoco/test/jacocoTestReport.csv >> coverage-summary.txt

          cat coverage-summary.txt
        else
          echo "No coverage report generated" > coverage-summary.txt
        fi

    - name: Analyze code and generate fix with OpenAI
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Analyzing failures and generating fixes using OpenAI API..."

        # Read source files
        BUBBLE_SORT=$(cat src/main/java/BubbleSort.java)
        MERGE_SORT=$(cat src/main/java/MergeSort.java)
        FAILURES=$(cat failures.txt | head -50)
        COVERAGE_SUMMARY=$(cat coverage-summary.txt 2>/dev/null || echo "No coverage summary available")
        COVERAGE_VIOLATIONS=$(cat coverage-violations.txt 2>/dev/null || echo "No coverage violations detected")

        # Read test files for coverage context
        BUBBLE_SORT_TEST=$(cat src/test/java/BubbleSortTest.java 2>/dev/null || echo "No test file found")
        MERGE_SORT_TEST=$(cat src/test/java/MergeSortTest.java 2>/dev/null || echo "No test file found")

        # Escape special characters for JSON
        BUBBLE_SORT_ESCAPED=$(echo "$BUBBLE_SORT" | jq -Rs .)
        MERGE_SORT_ESCAPED=$(echo "$MERGE_SORT" | jq -Rs .)
        FAILURES_ESCAPED=$(echo "$FAILURES" | jq -Rs .)
        COVERAGE_SUMMARY_ESCAPED=$(echo "$COVERAGE_SUMMARY" | jq -Rs .)
        COVERAGE_VIOLATIONS_ESCAPED=$(echo "$COVERAGE_VIOLATIONS" | jq -Rs .)
        BUBBLE_SORT_TEST_ESCAPED=$(echo "$BUBBLE_SORT_TEST" | jq -Rs .)
        MERGE_SORT_TEST_ESCAPED=$(echo "$MERGE_SORT_TEST" | jq -Rs .)

        # Create prompt for OpenAI
        cat > prompt.json <<EOF
        {
          "model": "gpt-5",
          "messages": [
            {
              "role": "system",
              "content": "You are an expert Java developer specializing in test-driven development and code coverage optimization. Analyze test failures and coverage gaps, then provide corrected code. For coverage issues, suggest additional tests or modifications to existing code to improve coverage. Output format: FILE: filename followed by the complete corrected code."
            },
            {
              "role": "user",
              "content": "FAILED JOB: ${{ inputs.failed_job }}\n\n=== TEST FAILURES ===\n${FAILURES}\n\n=== COVERAGE VIOLATIONS ===\n${COVERAGE_VIOLATIONS}\n\n=== COVERAGE SUMMARY ===\n${COVERAGE_SUMMARY}\n\n=== SOURCE FILES ===\n\nBubbleSort.java:\n${BUBBLE_SORT}\n\nMergeSort.java:\n${MERGE_SORT}\n\n=== TEST FILES ===\n\nBubbleSortTest.java:\n${BUBBLE_SORT_TEST}\n\nMergeSortTest.java:\n${MERGE_SORT_TEST}\n\n=== REQUIREMENTS ===\nMinimum 80% overall coverage required.\nMinimum 70% per-class line coverage required.\n\nIf there are test failures, fix the source code. If there are coverage violations, add test cases to existing test files to cover untested branches and lines. Provide complete corrected files using format: FILE: filename.java followed by the complete code."
            }
          ],
          "temperature": 0.3,
          "max_tokens": 4000
        }
        EOF

        # Call OpenAI API
        RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $OPENAI_API_KEY" \
          -d @prompt.json)

        echo "$RESPONSE" > openai-response.json

        # Extract the fix from response
        FIX=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
        echo "$FIX" > suggested-fix.txt

        echo "OpenAI suggested fix:"
        echo "$FIX"

    - name: Apply suggested fixes
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Attempting to apply AI-suggested fixes..."

        # Parse and apply fixes (this is a simplified version)
        # In a real scenario, you'd parse the FILE: markers and extract code blocks

        if grep -q "FILE: BubbleSort.java" suggested-fix.txt; then
          echo "BubbleSort fix detected, backing up original..."
          cp src/main/java/BubbleSort.java src/main/java/BubbleSort.java.backup
          # Note: Actual parsing and application would need more sophisticated logic
          echo "Fix application would happen here with proper parsing"
        fi

        if grep -q "FILE: MergeSort.java" suggested-fix.txt; then
          echo "MergeSort fix detected, backing up original..."
          cp src/main/java/MergeSort.java src/main/java/MergeSort.java.backup
          echo "Fix application would happen here with proper parsing"
        fi

        if grep -q "FILE: BubbleSortTest.java" suggested-fix.txt; then
          echo "BubbleSortTest fix detected, backing up original..."
          cp src/test/java/BubbleSortTest.java src/test/java/BubbleSortTest.java.backup
          echo "Test fix application would happen here with proper parsing"
        fi

        if grep -q "FILE: MergeSortTest.java" suggested-fix.txt; then
          echo "MergeSortTest fix detected, backing up original..."
          cp src/test/java/MergeSortTest.java src/test/java/MergeSortTest.java.backup
          echo "Test fix application would happen here with proper parsing"
        fi

    - name: Verify fixes
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Re-running tests and coverage checks..."
        ./gradlew clean test jacocoTestReport jacocoTestCoverageVerification --no-daemon --stacktrace 2>&1 | tee verify-output.log || true

        # Check if fixes resolved the issues
        if grep -q "BUILD SUCCESSFUL" verify-output.log; then
          echo "✅ Fixes appear to have resolved the issues!"
          echo "fix_successful=true" >> $GITHUB_OUTPUT
        else
          echo "⚠️ Issues may still persist after applying fixes"
          echo "fix_successful=false" >> $GITHUB_OUTPUT
        fi

    - name: Upload analysis artifacts
      if: always() && steps.check_key.outputs.has_key == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: autofix-analysis-${{ github.run_id }}
        path: |
          test-output.log
          failures.txt
          coverage-output.log
          coverage-violations.txt
          coverage-summary.txt
          coverage-report.csv
          openai-response.json
          suggested-fix.txt
          verify-output.log
          prompt.json
          src/main/java/*.backup
          src/test/java/*.backup
        retention-days: 7
