name: Auto-Fix CI Failures

on:
  workflow_call:
    inputs:
      failed_job:
        description: 'Name of the job that failed'
        required: true
        type: string
      run_url:
        description: 'URL of the failed workflow run'
        required: true
        type: string
      branch:
        description: 'Branch where the failure occurred'
        required: true
        type: string
      sha:
        description: 'Commit SHA where the failure occurred'
        required: true
        type: string
  workflow_dispatch:
    inputs:
      failed_job:
        description: 'Name of the job that failed'
        required: true
        type: string
      branch:
        description: 'Branch to fix'
        required: true
        default: 'main'

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

    steps:
    - name: Check OpenAI API Key
      id: check_key
      run: |
        if [ -z "$OPENAI_API_KEY" ]; then
          echo "⚠️ OPENAI_API_KEY secret is not set. Skipping auto-fix."
          echo "To enable auto-fix, add OPENAI_API_KEY to repository secrets."
          echo "has_key=false" >> $GITHUB_OUTPUT
          exit 0
        else
          echo "✅ OPENAI_API_KEY is configured"
          echo "has_key=true" >> $GITHUB_OUTPUT
        fi

    - name: Checkout code
      if: steps.check_key.outputs.has_key == 'true'
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.sha || github.sha }}
        fetch-depth: 0

    - name: Set up JDK 17
      if: steps.check_key.outputs.has_key == 'true'
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: 'gradle'

    - name: Make gradlew executable
      if: steps.check_key.outputs.has_key == 'true'
      run: chmod +x gradlew

    - name: Collect failure information
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Collecting test failure information..."
        ./gradlew test --no-daemon --stacktrace 2>&1 | tee test-output.log || true

        # Extract relevant error information
        echo "Extracting failure details..."
        grep -A 10 "FAILED\|FAILURE\|Error" test-output.log > failures.txt || echo "No specific failures found in output"

    - name: Analyze code and generate fix with OpenAI
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Analyzing failures and generating fixes using OpenAI API..."

        # Read source files
        BUBBLE_SORT=$(cat src/main/java/BubbleSort.java)
        MERGE_SORT=$(cat src/main/java/MergeSort.java)
        FAILURES=$(cat failures.txt | head -50)

        # Create prompt for OpenAI
        cat > prompt.json <<EOF
        {
          "model": "gpt-4",
          "messages": [
            {
              "role": "system",
              "content": "You are an expert Java developer. Analyze test failures and provide ONLY the corrected code. Output only valid Java code, no explanations."
            },
            {
              "role": "user",
              "content": "FAILED JOB: ${{ inputs.failed_job }}\n\nTest failures:\n${FAILURES}\n\nBubbleSort.java:\n${BUBBLE_SORT}\n\nMergeSort.java:\n${MERGE_SORT}\n\nProvide the corrected Java code for any failing class. Output format: FILE: filename.java followed by the complete corrected code."
            }
          ],
          "temperature": 0.3,
          "max_tokens": 2000
        }
        EOF

        # Call OpenAI API
        RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $OPENAI_API_KEY" \
          -d @prompt.json)

        echo "$RESPONSE" > openai-response.json

        # Extract the fix from response
        FIX=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
        echo "$FIX" > suggested-fix.txt

        echo "OpenAI suggested fix:"
        echo "$FIX"

    - name: Apply suggested fixes
      if: steps.check_key.outputs.has_key == 'true'
      run: |
        echo "Attempting to apply AI-suggested fixes..."

        # Parse and apply fixes (this is a simplified version)
        # In a real scenario, you'd parse the FILE: markers and extract code blocks

        if grep -q "FILE: BubbleSort.java" suggested-fix.txt; then
          echo "BubbleSort fix detected, backing up original..."
          cp src/main/java/BubbleSort.java src/main/java/BubbleSort.java.backup
          # Note: Actual parsing and application would need more sophisticated logic
          echo "Fix application would happen here with proper parsing"
        fi

        if grep -q "FILE: MergeSort.java" suggested-fix.txt; then
          echo "MergeSort fix detected, backing up original..."
          cp src/main/java/MergeSort.java src/main/java/MergeSort.java.backup
          echo "Fix application would happen here with proper parsing"
        fi

    - name: Upload analysis artifacts
      if: always() && steps.check_key.outputs.has_key == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: autofix-analysis-${{ github.run_id }}
        path: |
          test-output.log
          failures.txt
          openai-response.json
          suggested-fix.txt
        retention-days: 7
